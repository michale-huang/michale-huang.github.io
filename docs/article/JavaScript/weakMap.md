# WeakMap :point_left:

## 定义
> `WeakMap`是ES2015（ES6）中新增的几种数据类型之一，`WeakMap` 对象是键/值对的集合，有点类似`Map`, 但与`Map`又有以下两个主要区别：
> 
> 1. `WeakMap`对键的引用是弱引用的
> 2. `WeakMap`键只能是对象，而值则可以是任意的

对于第一点，弱引用正是`WeakMap`中Weak的含义。我们知道当一个对象被引用的时候，往往意味着它正在被使用，或者在将来有可能会被使用，此时对象不会被垃圾回收机制回收掉。`WeakMap` 持有的是每个键或值对象的“弱引用”，弱引用则可以理解为“引用了对象，但是不影响它的垃圾回收”，这样在没有其他引用存在时垃圾回收能正确进行。

```js
var obj = {}
var wm = new WeakMap()
wm.set(obj, 1)
wm.get(obj) // 1
// ......
obj = null
wm.get(obj)
```

在这个例子中，`WeakMap`实例 `wm`（弱）引用了obj对象（空对象），接着下方代码释放了对空对象的引用（`obj = null`），此时和上例一样，空对象将被垃圾回收。也即 `wm` 中持有的空对象（弱）引用并不影响对对象本身的垃圾回收。这就是`WeakMap中`“弱引用”的含义。

## 使用场景

客观地说，WeakMap的使用场景并不是很多，而且在条件不是非常苛刻的前提下，一般都可以有替代解决方案。不过很多情况下使用WeakMap来解决问题会更简单可靠一些。举个例子，*在不改变对象本身的情况下扩展对象*：

怎么理解呢？假如有100只鸡，现在要对每只鸡称重并记录。那么，鸡的体重记录到哪里就成了一个问题。我们有两种选择：
1. 记录到一个本本上
2. 想办法用笔写到鸡身上
```js
// 1只鸡
var chicken = new Chicken();
// 100只鸡
var chickenList = [chicken, xxx, ...];
// 方法1:记录到本本上
var notebook = [];
chickenList.forEach(function(chickenItem, index){
	notebook[index] = getWeight(chickenItem);
});
// 方法2:记录到鸡身上
chickenList.forEach(function(chickenItem, index){
	chickenItem.weight = getWeight(chickenItem);
});
```
首先我们看一下第2种方法，记录到鸡身上。这种方法的好处在于我们不需要额外的笔记本（变量）。但同时它也有很明显的缺点：

* 破坏了鸡的卖相，有时候这是很严重的事情，比如你想把一只5斤的鸡当成6斤卖出去，结果鸡身上直接写“我只有5斤”（修改了原有对象，可能导致意外的行为）
* 可能碰到一些战斗鸡，一个字都写不上去（对象冻结了或者有不可覆盖的属性）
* 可能写到一些本来就写了字的地方，导致根本看不清（与对象原有属性冲突）
* 如果鸡的生产线上有光学设备，有可能破坏生产线的生产，因为这只鸡变成了一只非标品，只能使用人工生产，降低效率（破坏JS引擎的hidden class优化机制）

我们再来看一下第1种方法。这种方法的好处在于完全不用改动原来的对象，但它有比较明显的问题：

* 需要一个专门的本本来记录结果（额外变量）
* 本本无法和鸡精准地一一对应，只能靠一些索引或者标记（例如给每只鸡起一个名字）去（不可靠）地记录对应关系（无法精准地对比到是哪一个对象）
* 本本上的结果可以随时被别人修改

针对上述第2个问题，一般我们在日常开发中，都会给对象加上一些标识，例如id属性，去与notebook记录的数据做一一对应。这也是我们在处理这一类需求的时候，一般不会觉得有困扰的原因。但这只适用于你能控制chicken对象结构的情况。如果你并不知道你要处理是一个什么样的对象，那么这种方法就会面临上方提到的第2个问题。

这样的需求用Map是否可以解决呢？答案是肯定的：
```js
// 1只鸡
var chicken = new Chicken();
// 100只鸡
var chickenList = [chicken, xxx, ...];
// 记录到另一个本本上
var notebook = new Map();
chickenList.forEach(function(chickenItem, index){
	notebook.set(chickenItem, getWeight(chickenItem));
});
```
这里将本本notebook换成了一个Map，而Map可以保留对chicken的引用，从而解决上面说的使用数组或者对象来记录时无法精准对应的问题。

这里用Map解决了上述第2个问题，但仍然存在两个问题：
* 需要额外变量notebook来存储所有的重量数据
* notebook中的数据可能随时被别人修改

此时，我们终于可以看看WeakMap在这个问题上是如何表现的了：
```js
// 1只鸡
var chicken = new Chicken();
// 100只鸡
var chickenList = [chicken, xxx, ...];
// 记录到WeakMap
var notebook = new WeakMap();
chickenList.forEach(function(chickenItem, index){
	notebook.set(chickenItem, getWeight(chickenItem));
});
```
咦？怎么感觉跟Map的例子一样一样的？没错。Map和WeakMap的作用和用法非常相似。但是因为WeakMap弱引用和不可遍历，这里有一些不同的事情：

当你拿到chicken引用的时候，获取重量并记录到WeakMap notbook中，但是一旦释放chicken，则notebook中对应的数据也无法再访问，这可以很好地节省内存
因为notebook不可遍历，也就意味着你只有在需要使用chicken（有引用）时，才可以访问notebook，可以有效防止被外部修改

打个比方，你的本本上，关于这只鸡的记录，只有当鸡来了的时候才存在，而且只有鸡在场的时候才能查到，当鸡走了，在本本上关于鸡的记录是不存在的，也就不存在被别人偷看、修改一说。也就是说，这个本本上关于鸡的记录好像根本就是这只鸡自己带来的一样。这就是上方所说的在不改变对象本身的情况下扩展对象的含义。

同样的原理和写法，可以应用到其它的场景中，比如标记对象的状态（用于任务调度、错误处理等），比如为DOM元素添加额外的关联数据等等。

[更多应用场景](https://zhuanlan.zhihu.com/p/25454328)

## 循环引用的垃圾回收问题

### 垃圾回收

根据 Wiki 的定义，垃圾回收是一种自动的内存管理机制。当计算机上的动态内存不再需要时，就应该予以释放，以让出内存。直白点讲，就是程序是运行在内存里的，当声明一个变量、定义一个函数时都会占用内存。内存的容量是有限的，如果变量、函数等只有产生没有消亡的过程，那迟早内存有被完全占用的时候。所以，在计算机中，我们需要垃圾回收。需要注意的是，定义中的“自动”的意思是语言可以帮助我们回收内存垃圾，但并不代表我们不用关心内存管理，如果操作失当，JavaScript 中依旧会出现内存溢出的情况。

垃圾回收基于两个原理：

* 确人某个变量／对象在未来的程序运行中将不会被访问
* 向这些变量／对象要求归还内存

而这两个原理中，最主要的也是最艰难的部分就是找到“所分配的内存确实已经不再需要了”。`JavaScript` 主要通过两种方式：**引用计数(reference counting)** 和 **标记-清除(mark and sweep)** 来找到不再使用的内存的。

> 标记-清除: JavaScript 中有个全局对象，浏览器中是 window。定期的，垃圾回收期将从这个全局对象开始，找所有从这个全局对象开始引用的对象，再找这些对象引用的对象...对这些活着的对象进行标记，这是标记阶段。清除阶段就是清除那些没有被标记的对象。

这是 `JavaScript` 中最常见的垃圾回收方式。为什么说这是种最常见的方法，因为从 2012 年起，所有现代浏览器都使用了标记-清除的垃圾回收方法, 除了低版本 IE...它们采用的是引用计数方法。

标记清除有一个问题，就是在清除之后，内存空间是不连续的，即出现了内存碎片。如果后面需要一个比较大的连续的内存空间时，那将不能满足要求。而标记-整理方法可以有效地解决这个问题。标记阶段没有什么不同，只是标记结束后，标记-整理方法会将活着的对象向内存的一边移动，最后清理掉边界的内存。不过可以想象，这种做法的效率没有标记-清除高。标记-整理方法可有效避免了循环引用的问题

> 引用计数: 在内存管理环境中，对象 A 如果有访问对象 B 的权限，叫做对象 A 引用对象 B。引用计数的策略是将“对象是否不再需要”简化成“对象有没有其他对象引用到它”，如果没有对象引用这个对象，那么这个对象将会被回收。
