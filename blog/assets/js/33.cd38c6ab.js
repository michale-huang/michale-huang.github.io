(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{381:function(e,s,o){"use strict";o.r(s);var t=o(43),v=Object(t.a)({},(function(){var e=this,s=e.$createElement,o=e._self._c||s;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"聊聊token那些事"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#聊聊token那些事"}},[e._v("#")]),e._v(" 聊聊token那些事")]),e._v(" "),o("h2",{attrs:{id:"作用"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[e._v("#")]),e._v(" 作用")]),e._v(" "),o("ul",[o("li",[e._v("用户标示／通行证： http请求是无状态的，无法识别用户身份")]),e._v(" "),o("li",[e._v("减少服务器压力：减少直接校验userid和paassword的过程即减少了不断从主数据库查询数据的压力")])]),e._v(" "),o("h2",{attrs:{id:"原理"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),o("p",[e._v("用户第一次登录，服务器通过数据库校验其UserId和Password合法，则再根据\n随机数字+userid+当前时间戳， 再经过DES加密生成一个token串并返回给客户端")]),e._v(" "),o("h2",{attrs:{id:"当token过期时"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#当token过期时"}},[e._v("#")]),e._v(" 当token过期时")]),e._v(" "),o("p",[e._v("当一个token过期时，前端通常有两种方式来重新获得token：")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("直接跳转到登录用户，引导用户重新登录去获得新token")])]),e._v(" "),o("li",[o("p",[e._v("自动发起请求去拿新的token")])])]),e._v(" "),o("p",[e._v("第一种方案，首先需要与后端的同学约定token过期时返回的"),o("code",[e._v("status code")]),e._v("，比如:401, 然后前端的请求拦截器处理当code为401时，路由自动跳转到登录页面;")]),e._v(" "),o("p",[e._v("如果token失效时间很短，采用第一种方案让用户一直重新登录显然是非常影响用户体验的，那么就需要采用第二种方案")]),e._v(" "),o("p",[e._v("当前端请求拦截器拦截到返回的code为401时，此时发起一个请求去获取新的token，这里需要考虑一个问题，既然token已经过期了，又不能让用户输入用户名密码，那么怎么获取新的token呢？")]),e._v(" "),o("p",[e._v("这时需要了解两个东西："),o("code",[e._v("accessToken")]),e._v("和"),o("code",[e._v("refreshToken")]),e._v("，前文提到的服务端通过token来辨识用户，这里的token确切的说应该叫"),o("code",[e._v("accessToken")]),e._v(",用于资源访问；而当"),o("code",[e._v("accessToken")]),e._v("过期时，则可以通过"),o("code",[e._v("refreshToken")]),e._v("获得新的"),o("code",[e._v("accessToken")])]),e._v(" "),o("p",[e._v("了解了以上，那么第二种方案完整描述如下：")]),e._v(" "),o("blockquote",[o("p",[e._v("用户登录 —> 服务端校验其用户名密码是否合法，合法则返回一对"),o("code",[e._v("accessToken")]),e._v("与"),o("code",[e._v("refreshToken")]),e._v(" —> 客户端将一对token存储起来并在之后的请求中带上"),o("code",[e._v("accessToken")]),e._v(" —> "),o("code",[e._v("accessToken")]),e._v("过期时服务端返回token过期信息如"),o("code",[e._v("status code: 401")]),e._v(" —> 客户端拦截到返回code 401的请求，并发起获取新token的请求，该请求会带上"),o("code",[e._v("refreshToken")]),e._v(" —> 服务端校验通过后返回一对新的"),o("code",[e._v("accessToken")]),e._v("与"),o("code",[e._v("refreshToken")])])]),e._v(" "),o("h2",{attrs:{id:"token和session"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#token和session"}},[e._v("#")]),e._v(" token和session")]),e._v(" "),o("p",[e._v("token和session的功能是一样的，都是为了与浏览器建立连接并获取服务端的用户数据，二者只是实现方式不一样。")]),e._v(" "),o("p",[e._v("用户登录时，服务端将user存入session并生成一个唯一ID, 然后将该sessionID存入浏览器的cookie中，再次访问时根据cookie即可查找到相应的user")])])}),[],!1,null,null,null);s.default=v.exports}}]);